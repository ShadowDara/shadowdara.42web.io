<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Geschützte Seite — Passwort speichern</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,Arial;padding:2rem;max-width:800px;margin:auto}
  #content{border:1px solid #ddd;padding:1rem;margin-top:1rem;display:none}
  .error{color:#a00}
  .hidden{display:none}
</style>
</head>
<body>
  <h1>Geschützter Inhalt</h1>

  <!-- Visuelle Login-UI (benötigt für Nutzer und für Browser-Save prompts) -->
  <form id="unlockForm" autocomplete="on" action="#" method="post" novalidate>
    <label for="username">Benutzername (frei wählbar):</label><br />
    <input id="username" name="username" autocomplete="username" placeholder="Benutzername" value="protected-user" /><br /><br />

    <label for="pw">Passwort:</label><br />
    <input id="pw" name="password" type="password" autocomplete="current-password" placeholder="Passwort" />
    <button id="unlock" type="button">Entschlüsseln</button>
    <label style="margin-left:1rem"><input id="remember" type="checkbox" checked /> Passwort speichern</label>
  </form>

  <div id="status"></div>
  <div id="content"></div>

  <!-- Verstecktes Fallback-Formular für Browser, die Save-Prompt nur bei Form-Submit zeigen -->
  <form id="fallbackSaveForm" class="hidden" action="#" method="post">
    <input id="fsf_user" name="username" />
    <input id="fsf_pw" name="password" type="password" />
    <button type="submit">Save</button>
  </form>

<script>
// ======= Hier das verschlüsselte Paket einfügen (wie zuvor) =======
// Ersetze Platzhalterwerte mit den Werten aus deinem encrypt.js-Ausgabe
const encryptedPackage = 
{
  "salt": "Ue8Gd2Z/elc5kVpweMHstQ==",
  "iv": "jZuFoFWJI2GPYFZ9",
  "ct": "yoCl2LdSwooP0lERuZgCBbLdKSdv8xZ+1bqo1WN4u7uPUOff3LEq73RxLOx5T5iiWdP42C7PJ5m0zboutWV7Gzc1B6nrqtVGIZFZwQga7fy2FWlacq877XcwRBURXqJ5FpMwJWUO/5jAJMCDV9+2VfVE6rmWCv2ioTmn9WoQCNoivh6yvEEuYgaV0veD8JbRuyCEFLxhYgDQUJBal/ftjvknfJ7fBQBDHl8w78uZb91e9KnTetgmepTlOuOQAdZr3YVvC/+FNnTYn7OOpuSkJ3rSXW9U",
  "tag": "ORFHKMYghmQm5tJ8abZ30Q=="
}
;
// =================================================================

/* ---- Hilfsfunktionen ---- */
function b64ToBuf(b64){ return Uint8Array.from(atob(b64), c => c.charCodeAt(0)); }
function bufToStr(buf){ return new TextDecoder().decode(buf); }

async function deriveKey(password, salt, iterations=150000, keyLen=32){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: salt, iterations: iterations, hash: "SHA-256" },
    baseKey,
    { name: "AES-GCM", length: keyLen*8 },
    false,
    ["decrypt"]
  );
}

async function decryptAesGcm(key, iv, ciphertext, tag){
  const combined = new Uint8Array(ciphertext.length + tag.length);
  combined.set(ciphertext, 0);
  combined.set(tag, ciphertext.length);
  const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, combined);
  return new Uint8Array(plain);
}

/* ---- UI-Elemente ---- */
const pwInput = document.getElementById('pw');
const userInput = document.getElementById('username');
const rememberCheckbox = document.getElementById('remember');
const status = document.getElementById('status');
const contentDiv = document.getElementById('content');
const unlockBtn = document.getElementById('unlock');
const fallbackSaveForm = document.getElementById('fallbackSaveForm');

async function attemptUnlockWithPassword(pw, storeIfOk = false){
  status.textContent = 'Entschlüssele...';
  status.className = '';
  try {
    if (encryptedPackage.salt.includes('REPLACE_')) throw new Error('Kein verschlüsseltes Paket hinterlegt.');
    const salt = b64ToBuf(encryptedPackage.salt);
    const iv   = b64ToBuf(encryptedPackage.iv);
    const ct   = b64ToBuf(encryptedPackage.ct);
    const tag  = b64ToBuf(encryptedPackage.tag);

    const key = await deriveKey(pw, salt);
    const plainBuf = await decryptAesGcm(key, iv, ct, tag);
    const text = bufToStr(plainBuf);

    contentDiv.style.display = 'block';
    contentDiv.innerHTML = text;
    status.textContent = 'Erfolgreich entschlüsselt.';

    if (storeIfOk && rememberCheckbox.checked) {
      await tryStoreCredential(userInput.value || 'protected-user', pw);
    }
    return true;
  } catch (err) {
    console.error(err);
    status.textContent = 'Fehler: Passwort falsch oder Daten beschädigt.';
    status.className = 'error';
    return false;
  }
}

/* ---- Credential Management API + Fallback ---- */
async function tryStoreCredential(username, password){
  try {
    // Moderne API (Navigator Credentials) — einige Browser (Chrome, Edge, Opera) unterstützen PasswordCredential
    if (window.PasswordCredential && navigator.credentials && navigator.credentials.store) {
      const credData = {
        id: username || 'protected-user',
        name: username || '',
        password: password
      };
      // Some browsers require an actual form element — but navigator.credentials.store() works in many.
      const pc = new PasswordCredential(credData);
      await navigator.credentials.store(pc);
      console.log('Credential via navigator.credentials.store() gespeichert.');
      return;
    }
  } catch (e) {
    console.warn('Credential API store failed:', e);
  }

//   // Fallback: verstecktes Formular befüllen und submitten — manche Browser zeigen Save-Prompt nur on form submit
//   try {
//     document.getElementById('fsf_user').value = username || 'protected-user';
//     document.getElementById('fsf_pw').value = password;
//     // Verwende requestSubmit (besser als .submit(), da es Events feuert)
//     fallbackSaveForm.requestSubmit();
//     console.log('Fallback: Formular submission ausgelöst (Save-Prompt kann erscheinen).');
//   } catch (e) {
//     console.warn('Fallback save failed:', e);
//   }
}

/* ---- Try to auto-fill stored credential on load ---- */
async function tryAutoFillAndUnlock(){
  // 1) Credential Management API: hole gespeicherte PasswordCredential
  try {
    if (navigator.credentials && navigator.credentials.get) {
      const opts = { password: true, mediation: 'optional' }; // 'optional' -> zeigt UI nur wenn vorhanden
      const cred = await navigator.credentials.get(opts);
      if (cred) {
        // cred.id ist häufig username; cred.password das Passwort
        if (cred.id) userInput.value = cred.id;
        if (cred.password) {
          pwInput.value = cred.password;
          // automatisch versuchen zu entsperren (storeIfOk = false, weil es bereits gespeichert ist)
          await attemptUnlockWithPassword(cred.password, false);
          return;
        }
      }
    }
  } catch (e) {
    console.warn('Auto-fetch credentials failed:', e);
  }

  // 2) Manche Browser füllen das Passwordfeld automatisch. Warte kurz und falls gefüllt, versuche zu entsperren.
  setTimeout(() => {
    if (pwInput.value) {
      attemptUnlockWithPassword(pwInput.value, false);
    }
  }, 200); // kleiner Delay für Autofill
}

/* ---- Events ---- */
unlockBtn.addEventListener('click', async () => {
  const pw = pwInput.value;
  if (!pw) {
    status.textContent = 'Bitte Passwort eingeben.';
    status.className = 'error';
    return;
  }
  const ok = await attemptUnlockWithPassword(pw, true);
  // wenn erfolgreich, stoppe hier (Credential store bereits ausgelöst)
});

document.getElementById('unlockForm').addEventListener('submit', (e) => {
  // verhindern, dass das Seite neu lädt (wir wollen clientseitige Entschlüsselung)
  e.preventDefault();
});

// Versuche beim Laden gespeicherte Daten zu verwenden
window.addEventListener('load', () => {
  tryAutoFillAndUnlock();
});

</script>
</body>
</html>
